---
phase: 2
plan: 1
depends_on: []
must_haves:
  - "packages/infra/ exists with valid package.json"
  - "sst.config.ts defines Lambda, API Gateway, DynamoDB resources"
  - "Package compiles with TypeScript"
  - "Integrated into monorepo workspace"
---

# Phase 2, Plan 1: Create SST v4 Infrastructure Package

## Goal
A new `packages/infra/` package with SST v4 config defining serverless resources for Draht.

## Tasks

<task type="auto">
  <n>Create infra package skeleton</n>
  <files>packages/infra/package.json, packages/infra/tsconfig.json</files>
  <action>
    Create packages/infra/ with:
    
    package.json:
    - name: "@draht/infra"
    - version: "0.55.3" (match other packages)
    - type: "module"
    - dependencies: sst (latest v4), aws-cdk-lib, constructs
    - devDependencies: @types/node, typescript
    
    tsconfig.json extending ../../tsconfig.base.json with:
    - outDir: "./dist"
    - rootDir: "./src"
    - strict: true
  </action>
  <verify>cat packages/infra/package.json | grep "@draht/infra"</verify>
  <done>Infra package skeleton exists</done>
</task>

<task type="auto">
  <n>Create sst.config.ts</n>
  <files>packages/infra/sst.config.ts</files>
  <action>
    Create SST v4 config file following the sst.dev patterns:
    
    ```ts
    /// <reference path="./.sst/platform/config.d.ts" />
    export default $config({
      app(input) {
        return {
          name: "draht",
          removal: input?.stage === "production" ? "retain" : "remove",
          home: "aws",
        };
      },
      async run() {
        // DynamoDB tables
        const sessionsTable = new sst.aws.Dynamo("Sessions", {
          fields: { pk: "string", sk: "string" },
          primaryIndex: { hashKey: "pk", rangeKey: "sk" },
        });
        
        const clientsTable = new sst.aws.Dynamo("Clients", {
          fields: { clientId: "string" },
          primaryIndex: { hashKey: "clientId" },
        });
        
        // API
        const api = new sst.aws.ApiGatewayV2("Api");
        
        // Lambda functions
        api.route("GET /health", {
          handler: "src/functions/health.handler",
          link: [sessionsTable, clientsTable],
        });
        
        api.route("GET /sessions", {
          handler: "src/functions/sessions.handler",
          link: [sessionsTable],
        });
        
        api.route("GET /clients", {
          handler: "src/functions/clients.handler",
          link: [clientsTable],
        });
        
        return { api: api.url };
      },
    });
    ```
  </action>
  <verify>cat packages/infra/sst.config.ts | grep "draht"</verify>
  <done>SST v4 config with Lambda, API Gateway, DynamoDB defined</done>
</task>

<task type="auto">
  <n>Create Lambda function handlers</n>
  <files>packages/infra/src/functions/health.ts, packages/infra/src/functions/sessions.ts, packages/infra/src/functions/clients.ts</files>
  <action>
    Create minimal Lambda function handlers:
    
    health.ts - returns { status: "ok", service: "draht", timestamp }
    sessions.ts - stub handler for session management (returns placeholder)
    clients.ts - stub handler for client management (returns placeholder)
    
    Each handler should:
    - Use standard APIGatewayProxyHandlerV2 type from aws-lambda
    - Return proper JSON responses with statusCode, headers, body
    - Import Resource from "sst" for linked resource access (commented out until deployed)
  </action>
  <verify>ls packages/infra/src/functions/ — should show 3 .ts files</verify>
  <done>Lambda handlers exist with proper structure</done>
</task>

<task type="auto">
  <n>Update monorepo workspace config</n>
  <files>package.json</files>
  <action>
    Add "packages/infra" to the workspaces array in root package.json.
    Note: Don't add to the build script yet — infra uses SST's build, not the monorepo build.
  </action>
  <verify>grep "packages/infra" package.json</verify>
  <done>Infra package is part of the monorepo workspace</done>
</task>
