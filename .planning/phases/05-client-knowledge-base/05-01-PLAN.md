---
phase: 5
plan: 1
depends_on: []
must_haves:
  - "packages/knowledge/ exists with valid package.json and TypeScript structure"
  - "Zvec wrapper module provides index/search/delete operations"
  - "Client config model defines namespace isolation"
---

# Phase 5, Plan 1: Knowledge Package Foundation

## Goal
Create the @draht/knowledge package with Zvec vector DB wrapper and client data model.

## Context
Using Zvec (SQLite + OpenAI embeddings) for local-first vector storage. Each client gets isolated namespace under ~/.draht/knowledge/{slug}/.

## Tasks

<task type="auto">
  <n>Create knowledge package scaffold</n>
  <files>packages/knowledge/package.json, packages/knowledge/tsconfig.json</files>
  <action>
    Create packages/knowledge/ with:
    - package.json: name @draht/knowledge, type module, main/types pointing to dist/
    - tsconfig.json extending ../../tsconfig.base.json
    - src/index.ts barrel export
    Dependencies: better-sqlite3 (for Zvec-style local DB), openai (for embeddings)
  </action>
  <verify>cat packages/knowledge/package.json | grep @draht/knowledge</verify>
  <done>Package scaffold exists with correct metadata</done>
</task>

<task type="auto">
  <n>Implement vector store module</n>
  <files>packages/knowledge/src/vector-store.ts</files>
  <action>
    Create VectorStore class wrapping SQLite + OpenAI embeddings:
    - constructor(dbPath: string, openaiApiKey: string)
    - async index(chunks: Chunk[]): Promise<void> — embed and store chunks
    - async search(query: string, limit?: number): Promise<SearchResult[]> — cosine similarity search
    - async delete(sourceFile: string): Promise<void> — remove chunks by source
    - Chunk type: { content: string, metadata: ChunkMetadata }
    - ChunkMetadata: { source: string, client: string, timestamp: number, type: 'decision' | 'convention' | 'pattern' | 'general' }
    - SearchResult: { content: string, metadata: ChunkMetadata, score: number }
    - SQLite schema: chunks(id, content, embedding BLOB, source, client, timestamp, type, content_hash)
    - Use content hash (SHA-256) for deduplication
  </action>
  <verify>bun run --cwd packages/knowledge tsgo --noEmit src/vector-store.ts 2>&1 | head -5</verify>
  <done>Vector store module compiles with full CRUD operations</done>
</task>

<task type="auto">
  <n>Implement client config and knowledge manager</n>
  <files>packages/knowledge/src/client-config.ts, packages/knowledge/src/knowledge-manager.ts</files>
  <action>
    client-config.ts:
    - ClientConfig type: { slug: string, name: string, agentsMdPath?: string, watchPaths?: string[] }
    - loadClientConfig(cwd: string): reads .draht/client.json or extracts from AGENTS.md
    - getKnowledgePath(slug: string): returns ~/.draht/knowledge/{slug}/

    knowledge-manager.ts:
    - KnowledgeManager class wrapping VectorStore with client awareness
    - constructor(clientSlug: string) — initializes store at getKnowledgePath(slug)
    - async indexFile(filePath: string): Promise<void> — chunk file, dedup, index
    - async searchKnowledge(query: string, mode?: SearchMode): Promise<SearchResult[]>
    - SearchMode: 'decide' | 'connect' | 'fuzzy' | 'general'
    - Chunking: split by headings/paragraphs, ~500 tokens per chunk
  </action>
  <verify>bun run --cwd packages/knowledge tsgo --noEmit src/knowledge-manager.ts 2>&1 | head -5</verify>
  <done>Client config loading and knowledge manager with search modes compile</done>
</task>

<task type="auto">
  <n>Add package to workspace and update barrel exports</n>
  <files>package.json, packages/knowledge/src/index.ts</files>
  <action>
    1. Add "packages/knowledge" to root package.json workspaces array
    2. Create src/index.ts that exports:
       - VectorStore, Chunk, ChunkMetadata, SearchResult from vector-store
       - ClientConfig, loadClientConfig, getKnowledgePath from client-config
       - KnowledgeManager, SearchMode from knowledge-manager
  </action>
  <verify>grep knowledge package.json</verify>
  <done>Package is part of workspace and has clean barrel exports</done>
</task>
